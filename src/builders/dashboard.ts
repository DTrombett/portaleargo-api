import type { APIDashboard, Dashboard } from "../types";
import { arrayToObject } from "../util";

/**
 * Build the dashboard data.
 * @param body - The API response
 * @returns The new data
 */
export const buildDashboard = (body: APIDashboard): Dashboard => {
	const [data] = body.data.dati;

	return {
		outOfClass: arrayToObject(data.fuoriClasse, (d) => ({
			type: d.operazione,
			date: new Date(d.datEvento).getTime(),
			description: d.descrizione,
			teacher: d.docente,
			annotations: d.nota,
			onLineFrequency: d.frequenzaOnLine,
		})),
		msg: data.msg,
		options: Object.fromEntries(data.opzioni.map((d) => [d.chiave, d.valore])),
		totalAverage: data.mediaGenerale,
		mensa: data.mensa,
		monthlyAverage: Object.values(data.mediaPerMese),
		subjectList: arrayToObject(data.listaMaterie, (d) => ({
			codTipo: d.codTipo,
			doAverage: d.faMedia,
			fullName: d.materia,
			scrut: d.scrut,
			shortName: d.abbreviazione,
		})),
		deleteLocalData: data.rimuoviDatiLocali,
		periods: arrayToObject(
			data.listaPeriodi,
			(d) => ({
				description: d.descrizione,
				endDate: new Date(d.datFine).getTime(),
				finalAverage: d.mediaScrutinio,
				hasFinalAverage: d.isMediaScrutinio,
				isFinal: d.isScrutinioFinale,
				periodCode: d.codPeriodo,
				singleVote: d.votoUnico,
				startDate: new Date(d.datInizio).getTime(),
			}),
			"pkPeriodo"
		),
		reminders: arrayToObject(data.promemoria, (d) => ({
			date: new Date(d.datEvento).getTime(),
			details: d.desAnnotazioni,
			endTime: d.oraFine,
			idTeacher: d.pkDocente,
			startTime: d.oraInizio,
			teacherName: d.docente,
			type: d.operazione,
			visibleType: d.flgVisibileFamiglia,
		})),
		board: arrayToObject(data.bacheca, (a) => ({
			date: new Date(a.datEvento).getTime(),
			details: a.messaggio,
			needAcknowledgement: a.pvRichiesta,
			category: a.categoria,
			acknowledgementDate: new Date(a.dataConfermaPresaVisione).getTime(),
			url: a.url,
			author: a.autore,
			expirationDate: a.dataScadenza,
			type: a.operazione,
			adRequest: a.adRichiesta,
			acknowledged: a.isPresaVisione,
			confirmationDate: a.dataConfermaAdesione,
			attachments: arrayToObject(a.listaAllegati, (b) => ({
				fileName: b.nomeFile,
				path: b.path,
				description: b.descrizioneFile,
				url: b.url,
			})),
			expirationConfirmDate: a.dataScadAdesione,
			confirmed: a.isPresaAdesioneConfermata,
		})),
		sharedFile: data.fileCondivisi,
		grades: arrayToObject(data.voti, (a) => ({
			date: new Date(a.datEvento).getTime(),
			periodId: a.pkPeriodo,
			gradeString: a.codCodice,
			grade: a.valore,
			practical: a.codVotoPratico === "S",
			teacher: a.docente,
			subjectId: a.pkMateria,
			gradeType: a.tipoValutazione,
			prg: a.prgVoto,
			type: a.operazione,
			testDescription: a.descrizioneProva,
			faMenoMedia: a.faMenoMedia,
			pkTeacher: a.pkDocente,
			description: a.descrizioneVoto,
			codType: a.codTipo,
			averageCount: a.numMedia,
			subject: a.desMateria,
			subjectDetails: {
				subjectSchool: {
					code: a.materiaLight.scuMateriaPK.codMin,
					schoolPrg: a.materiaLight.scuMateriaPK.prgScuola,
					subjectPrg: a.materiaLight.scuMateriaPK.prgMateria,
					year: a.materiaLight.scuMateriaPK.numAnno,
				},
				code: a.materiaLight.codMateria,
				name: a.materiaLight.desDescrizione,
				shortName: a.materiaLight.desDescrAbbrev,
				sectionCode: a.materiaLight.codSuddivisione,
				typeCode: a.materiaLight.codTipo,
				hasAverage: a.materiaLight.flgConcorreMedia === "S",
				aggregateCode: a.materiaLight.codAggrDisciplina,
				individualLessons: a.materiaLight.flgLezioniIndividuali,
				codInvalsi: a.materiaLight.codAggrInvalsi,
				ministerialCode: a.materiaLight.codMinisteriale,
				icon: a.materiaLight.icona,
				description: a.materiaLight.descrizione,
				hasInsufficiency: a.materiaLight.conInsufficienze,
				selected: a.materiaLight.selezionata,
				prgSubject: a.materiaLight.prgMateria,
				type: a.materiaLight.tipo,
				types: a.materiaLight.articolata,
				hasIndividualLessons: a.materiaLight.lezioniIndividuali,
				subjectId: a.materiaLight.idmateria,
			},
			comment: a.desCommento,
		})),
		newData: data.ricaricaDati,
		teacherList: arrayToObject(data.listaDocentiClasse, (a) => ({
			surname: a.desCognome,
			subjects: a.materie,
			name: a.desNome,
			email: a.desEmail,
		})),
		studentBoard: arrayToObject(data.bachecaAlunno, (a) => ({
			type: a.operazione,
			fileName: a.nomeFile,
			date: new Date(a.datEvento).getTime(),
			details: a.messaggio,
			parentDownload: a.flgDownloadGenitore,
			acknowledged: a.isPresaVisione,
		})),
		disabledProfile: data.profiloDisabilitato,
		periodAverage: Object.fromEntries(
			Object.entries(data.mediaPerPeriodo).map(([key, a]) => [
				key,
				{
					average: a.mediaGenerale,
					monthlyAverage: a.mediaMese,
					subjects: Object.fromEntries(
						Object.entries(a.listaMaterie).map(([k, b]) => [
							k,
							{
								oralTestsTotal: b.sommaValutazioniOrale,
								oralTestsCount: b.numValutazioniOrale,
								average: b.mediaMateria,
								writtenAverage: b.mediaScritta,
								total: b.sumValori,
								valueCount: b.numValori,
								testsCount: b.numVoti,
								writtenTestsCount: b.numValutazioniScritto,
								writtenTestsTotal: b.sommaValutazioniScritto,
								oralAverage: b.mediaOrale,
							},
						])
					),
				},
			])
		),
		subjectAverage: Object.fromEntries(
			Object.entries(data.mediaMaterie).map(([key, b]) => [
				key,
				{
					oralTestsTotal: b.sommaValutazioniOrale,
					oralTestsCount: b.numValutazioniOrale,
					average: b.mediaMateria,
					writtenAverage: b.mediaScritta,
					total: b.sumValori,
					valueCount: b.numValori,
					testsCount: b.numVoti,
					writtenTestsCount: b.numValutazioniScritto,
					writtenTestsTotal: b.sommaValutazioniScritto,
					oralAverage: b.mediaOrale,
				},
			])
		),
		selfCertification: data.autocertificazione,
		register: arrayToObject(data.registro, (a) => ({
			type: a.operazione,
			date: new Date(a.datEvento).getTime(),
			url: a.desUrl,
			teacherId: a.pkDocente,
			homeworks: a.compiti.map((b) => ({
				details: b.compito,
				dueDay: new Date(b.dataConsegna).getTime(),
			})),
			teacher: a.docente,
			subject: a.materia,
			subjectId: a.pkMateria,
			activities: a.attivita,
			hour: a.ora,
		})),
		schede: data.schede,
		prenotazioniAlunni: data.prenotazioniAlunni,
		notes: data.noteDisciplinari,
		id: data.pk,
		extraClasses: data.classiExtra,
		dailyEvents: arrayToObject(data.appello, (a) => ({
			type: a.operazione,
			date: new Date(a.datEvento).getTime(),
			description: a.descrizione,
			toJustify: a.daGiustificare,
			justified: a.giustificata === "S",
			eventCode: a.codEvento,
			teacher: a.docente,
			justificationComment: a.commentoGiustificazione,
			justificationDate: new Date(a.dataGiustificazione).getTime(),
			annotation: a.nota,
		})),
	};
};
